name: Build IPA (Gesture Fix)

on:
  workflow_dispatch:

env:
  APP_NAME: "SillyTavern"
  BUNDLE_ID: "com.tavern.ios"
  TARGET_URL: "http://100.86.55.29:8000"
  VERSION: "1.0.8"

jobs:
  build:
    runs-on: macos-latest
    
    steps:
      - uses: actions/checkout@v4
      - name: Install XcodeGen
        run: brew install xcodegen

      - name: Prepare Workspace
        run: |
          rm -rf *
          mkdir -p App/Sources
          mkdir -p App/Resources
          mkdir -p App/Resources/Base.lproj

      # 1. 启动画面 (必须有，这是物理全屏的基础)
      - name: Generate Launch Screen
        run: |
          cat > App/Resources/Base.lproj/LaunchScreen.storyboard <<EOF
          <?xml version="1.0" encoding="UTF-8"?>
          <document type="com.apple.InterfaceBuilder3.CocoaTouch.Storyboard.XIB" version="3.0" toolsVersion="21507" targetRuntime="iOS.CocoaTouch" propertyAccessControl="none" useAutolayout="YES" launchScreen="YES" useTraitCollections="YES" useSafeAreas="YES" colorMatched="YES" initialViewController="01J-lp-oVM">
              <device id="retina6_12" orientation="portrait" appearance="light"/>
              <dependencies>
                  <deployment identifier="iOS"/>
                  <plugIn identifier="com.apple.InterfaceBuilder.IBCocoaTouchPlugin" version="21505"/>
                  <capability name="Safe area layout guides" minToolsVersion="9.0"/>
                  <capability name="documents saved in the Xcode 8 format" minToolsVersion="8.0"/>
              </dependencies>
              <scenes>
                  <scene sceneID="EHf-IW-A2E">
                      <objects>
                          <viewController id="01J-lp-oVM" sceneMemberID="viewController">
                              <view key="view" contentMode="scaleToFill" id="Ze5-6b-2t3">
                                  <rect key="frame" x="0.0" y="0.0" width="393" height="852"/>
                                  <autoresizingMask key="autoresizingMask" widthSizable="YES" heightSizable="YES"/>
                                  <color key="backgroundColor" white="0.0" alpha="1" colorSpace="custom" customColorSpace="genericGamma22GrayColorSpace"/>
                              </view>
                          </viewController>
                          <placeholder placeholderIdentifier="IBFirstResponder" id="iYj-Kq-Ea1" userLabel="First Responder" sceneMemberID="firstResponder"/>
                      </objects>
                      <point key="canvasLocation" x="53" y="375"/>
                  </scene>
              </scenes>
          </document>
          EOF

      - name: Generate Icon
        run: |
          echo "iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8z8BQDwAEhQGAhKmMIQAAAABJRU5ErkJggg==" | base64 -d > App/Resources/AppIcon.png
          sips -z 1024 1024 App/Resources/AppIcon.png --out App/Resources/Icon1024.png

      # 2. 核心代码：注入“完美伪装”的全屏补丁
      - name: Write Swift Code
        run: |
          cat > App/Sources/SillyTavernApp.swift <<EOF
          import SwiftUI
          @main
          struct SillyTavernApp: App {
              var body: some Scene {
                  WindowGroup {
                      ContentView()
                  }
              }
          }
          EOF

          cat > App/Sources/ContentView.swift <<EOF
          import SwiftUI
          import WebKit

          struct ContentView: View {
              var body: some View {
                  ZStack {
                      Color.black.ignoresSafeArea()
                      WebView(url: URL(string: "${{ env.TARGET_URL }}")!)
                          .ignoresSafeArea() 
                  }
                  .statusBar(hidden: true)
                  .persistentSystemOverlays(.hidden)
              }
          }

          struct WebView: UIViewRepresentable {
              let url: URL
              func makeUIView(context: Context) -> WKWebView {
                  let config = WKWebViewConfiguration()
                  config.allowsInlineMediaPlayback = true
                  
                  // ⚠️ 关键点：显式禁止系统接管全屏
                  // 这会迫使网页只能通过我们注入的 JS 逻辑来运行，彻底断绝“下滑退出”的可能性
                  config.preferences.javaScriptCanOpenWindowsAutomatically = true
                  if #available(iOS 15.4, *) {
                      config.preferences.isElementFullscreenEnabled = false 
                  }
                  
                  let webView = WKWebView(frame: .zero, configuration: config)
                  webView.scrollView.bounces = false
                  webView.scrollView.contentInsetAdjustmentBehavior = .never
                  webView.isOpaque = false
                  webView.backgroundColor = .black
                  
                  // ⭐️ JS 终极全屏补丁
                  let scriptString = """
                  // 1. 样式补丁
                  var style = document.createElement('style');
                  style.innerHTML = `
                    .ios-fake-fullscreen {
                        position: fixed !important;
                        top: 0 !important;
                        left: 0 !important;
                        width: 100vw !important;
                        height: 100vh !important;
                        z-index: 99999999 !important;
                        background-color: black !important;
                        margin: 0 !important;
                        padding: 0 !important;
                        display: flex !important;
                        align-items: center !important;
                        justify-content: center !important;
                    }
                  `;
                  document.head.appendChild(style);

                  // 2. 定义伪装函数
                  function fakeEnterFullscreen() {
                      // 给当前元素加样式
                      this.classList.add('ios-fake-fullscreen');
                      
                      // 欺骗前端：发送所有可能的成功信号
                      // 很多卡片实际上是监听 video 的 webkitbeginfullscreen 事件
                      var evt1 = new Event('webkitbeginfullscreen');
                      this.dispatchEvent(evt1);
                      
                      var evt2 = new Event('fullscreenchange');
                      document.dispatchEvent(evt2);
                      
                      var evt3 = new Event('webkitfullscreenchange');
                      document.dispatchEvent(evt3);
                      
                      return Promise.resolve();
                  }

                  function fakeExitFullscreen() {
                      var els = document.querySelectorAll('.ios-fake-fullscreen');
                      els.forEach(el => {
                          el.classList.remove('ios-fake-fullscreen');
                          // 发送退出信号
                          el.dispatchEvent(new Event('webkitendfullscreen'));
                      });
                      
                      document.dispatchEvent(new Event('fullscreenchange'));
                      document.dispatchEvent(new Event('webkitfullscreenchange'));
                      return Promise.resolve();
                  }

                  // 3. 暴力劫持所有 API
                  // 不管它调的是 video 专用还是普通 dom 专用，全部拦截
                  HTMLElement.prototype.requestFullscreen = fakeEnterFullscreen;
                  HTMLElement.prototype.webkitRequestFullscreen = fakeEnterFullscreen;
                  
                  // 针对 Video 标签的特殊劫持 (这是很多前端卡的核心)
                  HTMLVideoElement.prototype.webkitEnterFullscreen = fakeEnterFullscreen;
                  HTMLVideoElement.prototype.enterFullscreen = fakeEnterFullscreen;

                  // 劫持退出
                  document.exitFullscreen = fakeExitFullscreen;
                  document.webkitExitFullscreen = fakeExitFullscreen;
                  """
                  
                  let userScript = WKUserScript(source: scriptString, injectionTime: .atDocumentEnd, forMainFrameOnly: false)
                  webView.configuration.userContentController.addUserScript(userScript)
                  
                  let request = URLRequest(url: url)
                  webView.load(request)
                  return webView
              }
              func updateUIView(_ uiView: WKWebView, context: Context) {}
          }
          EOF

      - name: Generate Project File
        run: |
          cat > project.yml <<EOF
          name: ${{ env.APP_NAME }}
          options:
            bundleIdPrefix: ${{ env.BUNDLE_ID }}
            deploymentTarget:
              iOS: "16.0"
          targets:
            ${{ env.APP_NAME }}:
              type: application
              platform: iOS
              sources: [App/Sources, App/Resources]
              settings:
                PRODUCT_BUNDLE_IDENTIFIER: ${{ env.BUNDLE_ID }}
                INFOPLIST_FILE: Info.plist
                IPHONEOS_DEPLOYMENT_TARGET: "16.0"
                CODE_SIGNING_ALLOWED: "NO"
                CODE_SIGNING_REQUIRED: "NO"
                ASSETCATALOG_COMPILER_APPICON_NAME: AppIcon
                INFOPLIST_KEY_UILaunchStoryboardName: LaunchScreen
              info:
                path: Info.plist
                properties:
                  NSAppTransportSecurity:
                    NSAllowsArbitraryLoads: true
                  UIStatusBarHidden: true
                  UIViewControllerBasedStatusBarAppearance: false
                  UILaunchStoryboardName: LaunchScreen
          EOF
          
          mkdir -p App/Sources/Assets.xcassets/AppIcon.appiconset
          mv App/Resources/Icon1024.png App/Sources/Assets.xcassets/AppIcon.appiconset/1024.png
          echo '{"images":[{"size":"1024x1024","idiom":"ios-marketing","filename":"1024.png","scale":"1x"},{"size":"1024x1024","idiom":"universal","platform":"ios","filename":"1024.png"}],"info":{"version":1,"author":"xcode"}}' > App/Sources/Assets.xcassets/AppIcon.appiconset/Contents.json

          xcodegen generate

      - name: Archive & Export
        run: |
          xcodebuild archive \
            -project "${{ env.APP_NAME }}.xcodeproj" \
            -scheme "${{ env.APP_NAME }}" \
            -configuration Release \
            -sdk iphoneos \
            -archivePath "./build/${{ env.APP_NAME }}.xcarchive" \
            -destination 'generic/platform=iOS' \
            CODE_SIGNING_ALLOWED=NO CODE_SIGNING_REQUIRED=NO AD_HOC_CODE_SIGNING_ALLOWED=YES

          mkdir -p Payload
          cp -r "./build/${{ env.APP_NAME }}.xcarchive/Products/Applications/${{ env.APP_NAME }}.app" Payload/
          zip -r "${{ env.APP_NAME }}.ipa" Payload

      - name: Upload Artifact
        uses: actions/upload-artifact@v4
        with:
          name: SillyTavern-NoGesture-IPA
          path: "*.ipa"
